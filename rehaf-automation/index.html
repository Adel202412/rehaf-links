<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>REHAF Automation ‚Äî Interactive Landing</title>
<meta name="theme-color" content="#00ab9a" />
<style>
  :root{
    --teal:#00ab9a;        /* primary */
    --teal-dark:#00786c;   /* darker teal */
    --accent:#00453e;      /* deep green */
    --ink:#0f172a;         /* dark text */
    --bg:#f7faf9;          /* soft light background */
  }
  /* reset */
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    background:
      radial-gradient(60rem 40rem at 110% -10%, rgba(0,171,154,.08), transparent 60%),
      radial-gradient(60rem 40rem at -10% -10%, rgba(0,120,108,.06), transparent 60%),
      linear-gradient(180deg, #fff 0%, var(--bg) 60%, #eef6f4 100%);
    color: var(--ink);
    overflow-x:hidden;
    cursor:none; /* we‚Äôll draw our own */
  }

  /* header */
  .header{
    position:sticky; top:0; z-index:30;
    backdrop-filter:saturate(1.1) blur(8px);
    background:rgba(255,255,255,.7);
    border-bottom:1px solid #e5eff0;
  }
  .wrap{max-width:1100px;margin:0 auto;padding:14px 20px;display:flex;align-items:center;justify-content:space-between}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{
    width:34px;height:34px;border-radius:10px;
    background:linear-gradient(135deg,var(--teal),#38c7b9,#82e2d8);
  }
  .brand span{font-weight:700;letter-spacing:.3px;color:var(--accent)}
  .cta{
    display:inline-flex;gap:10px;align-items:center;
    padding:10px 16px;border-radius:14px;
    color:#fff;background:var(--teal);font-weight:600;text-decoration:none;
    box-shadow:0 6px 16px rgba(0,171,154,.28);
  }
  .cta:hover{background:var(--teal-dark)}

  /* hero */
  .hero{
    max-width:1100px;margin:0 auto;padding:64px 20px 36px; position:relative;
  }
  h1{font-size:clamp(32px,5vw,56px);line-height:1.05;color:var(--accent);font-weight:900;}
  .lead{margin-top:14px;max-width:720px;color:#475569;font-size:clamp(16px,2.2vw,18px)}
  .buttons{margin-top:24px;display:flex;gap:12px;flex-wrap:wrap}
  .btn{
    padding:12px 18px;border-radius:14px;font-weight:700;text-decoration:none;display:inline-block
  }
  .btn.primary{background:var(--teal);color:#fff;box-shadow:0 10px 20px rgba(0,171,154,.25)}
  .btn.primary:hover{background:var(--teal-dark)}
  .btn.ghost{border:1px solid #cfe7e3;color:var(--teal);background:#fff}
  .btn.ghost:hover{border-color:var(--teal);}

  /* custom cursor ‚ÄúR‚Äù */
  .cursorR{
    position:fixed; left:0; top:0; transform:translate(-50%,-50%);
    width:40px; height:40px; border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    font-weight:900; font-family:inherit;
    color:#fff; background:linear-gradient(135deg,var(--teal),var(--teal-dark));
    text-shadow:0 1px 0 rgba(0,0,0,.2);
    box-shadow:0 6px 18px rgba(0,0,0,.12), 0 0 0 6px rgba(0,171,154,.12);
    pointer-events:none; z-index:50;
    transition: transform .08s ease-out;
  }

  /* spawned AI shapes */
  .shape{
    position:fixed; pointer-events:none; z-index:10;
    filter:drop-shadow(0 6px 14px rgba(0,0,0,.12));
    animation:floatFade 1200ms ease-out forwards;
  }
  @keyframes floatFade{
    0%{opacity:.88; transform:translate(-50%,-50%) scale(.6) rotate(0deg)}
    60%{opacity:.66; transform:translate(calc(-50% + 2px), calc(-50% - 6px)) scale(1.05) rotate(8deg)}
    100%{opacity:0; transform:translate(calc(-50% + 6px), calc(-50% - 18px)) scale(0.9) rotate(16deg)}
  }

  /* footer note */
  .foot{max-width:1100px;margin:32px auto 40px; padding:0 20px; color:#64748b; font-size:14px}
</style>
</head>
<body>

  <header class="header">
    <div class="wrap">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <span>REHAF Automation</span>
      </div>
      <a class="cta" href="mailto:info@rehaf.ae">Book Free Audit</a>
    </div>
  </header>

  <main class="hero">
    <h1>Automate. Orchestrate. Scale.</h1>
    <p class="lead">
      Move your mouse (or finger) and watch ‚ÄúAI shapes‚Äù grow from your path.
      We build Make.com workflows that connect ClickUp, Airtable, Gmail, Telegram, and Google Sheets ‚Äî so your team moves faster with fewer errors.
    </p>
    <div class="buttons">
      <a href="mailto:info@rehaf.ae" class="btn primary">Get Started</a>
      <a href="#how" class="btn ghost">How it Works</a>
    </div>
  </main>

  <p class="foot">
    Tip: On mobile, drag your finger ‚Äî shapes will follow your gesture. Palette: teal / deep green to match REHAF.
  </p>

  <!-- custom cursor ‚ÄúR‚Äù -->
  <div class="cursorR" id="cursorR">R</div>

<script>
(function(){
  const cursor = document.getElementById('cursorR');
  let lastSpawn = 0;
  const SPAWN_EVERY_MS = 24; // throttling for performance
  const SHAPES_MAX = 200;    // keep DOM light

  const palette = [
    'rgba(0,171,154,0.95)',  // --teal
    'rgba(0,120,108,0.95)',  // --teal-dark
    'rgba(0,69,62,0.95)',    // --accent
    'rgba(130,226,216,0.95)' // highlight
  ];

  function moveCursor(x,y){
    cursor.style.left = x + 'px';
    cursor.style.top  = y + 'px';
    // tiny scale pulse for ‚Äúalive‚Äù feeling
    cursor.style.transform = 'translate(-50%,-50%) scale(1.02)';
    requestAnimationFrame(()=>{ cursor.style.transform = 'translate(-50%,-50%) scale(1.0)'; });
  }

  function rand(min,max){ return Math.random()*(max-min)+min; }
  function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

  function spawnShape(x,y){
    const now = performance.now();
    if(now - lastSpawn < SPAWN_EVERY_MS) return;
    lastSpawn = now;

    // clean up if too many
    const existing = document.querySelectorAll('.shape');
    if(existing.length > SHAPES_MAX){
      for(let i=0;i<existing.length- SHAPES_MAX;i++){ existing[i].remove(); }
    }

    const d = document.createElement('div');
    d.className = 'shape';

    const size = rand(12, 46); // px
    const br1 = rand(30, 90), br2 = rand(30, 90), br3 = rand(30, 90), br4 = rand(30, 90);
    const c1 = pick(palette), c2 = pick(palette);

    // sometimes make a ring or a triangle-ish blob
    const isRing = Math.random() < 0.18;
    const isTri  = !isRing && Math.random() < 0.18;

    if(isTri){
      const triSize = size + rand(12, 26);
      d.style.width = triSize + 'px';
      d.style.height = triSize + 'px';
      d.style.background = 'conic-gradient(from '+rand(0,360)+'deg, '+c1+', '+c2+')';
      d.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
      d.style.borderRadius = '10%';
    }else{
      d.style.width = size + 'px';
      d.style.height = size + 'px';
      d.style.borderRadius = `${br1}% ${br2}% ${br3}% ${br4}% / ${br2}% ${br3}% ${br4}% ${br1}%`;
      if(isRing){
        d.style.background = 'transparent';
        d.style.border = '2px solid '+c1.replace('0.95','0.7');
      }else{
        d.style.background = `radial-gradient(circle at ${rand(20,80)}% ${rand(20,80)}%, ${c1}, ${c2})`;
      }
    }

    d.style.left = x + 'px';
    d.style.top  = y + 'px';

    // subtle random rotation offset
    d.style.transform = `translate(-50%,-50%) rotate(${rand(-8,8)}deg)`;

    d.addEventListener('animationend', ()=> d.remove(), {once:true});
    document.body.appendChild(d);
  }

  // mouse & touch support
  window.addEventListener('mousemove', (e)=>{
    moveCursor(e.clientX, e.clientY);
    spawnShape(e.clientX, e.clientY);
  }, {passive:true});

  window.addEventListener('touchmove', (e)=>{
    const t = e.touches[0];
    if(!t) return;
    moveCursor(t.clientX, t.clientY);
    spawnShape(t.clientX, t.clientY);
  }, {passive:true});

  // hide ‚ÄúR‚Äù when leaving window
  window.addEventListener('mouseleave', ()=> cursor.style.opacity = '0');
  window.addEventListener('mouseenter', ()=> cursor.style.opacity = '1');

  // initial center position
  moveCursor(window.innerWidth/2, window.innerHeight/2);
})();
</script>

<!-- ===== RUNNER GAME (bottom-center) ===== -->
<style>
  :root{
    --teal:#00ab9a; --teal-dark:#00786c; --accent:#00453e;
  }
  .runner-wrap{
    width:100%;
    display:flex; justify-content:center;
    margin:42px 0 28px;
  }
  .runner-card{
    width:min(92vw, 760px);
    background:#ffffff;
    border:1px solid #e6eef0;
    border-radius:16px;
    box-shadow:0 8px 24px rgba(0,0,0,.06);
    padding:12px 12px 6px;
  }
  .runner-head{
    display:flex; justify-content:space-between; align-items:center;
    padding:0 6px 8px; color:#475569; font-size:14px;
  }
  .runner-head b{ color:var(--accent); }
  #rehafRunner{ width:100%; height:180px; display:block; }
  .runner-help{
    text-align:center; color:#64748b; font-size:12px; padding:6px 0 2px;
  }
</style>

<div class="runner-wrap" id="runner-game">
  <div class="runner-card">
    <div class="runner-head">
      <div>üéÆ <b>REHAF Runner</b> ‚Äî tap or press <b>Space/‚Üë/W</b> to jump</div>
      <div>Score: <span id="runnerScore">0</span></div>
    </div>
    <canvas id="rehafRunner" width="760" height="180" aria-label="REHAF Runner game"></canvas>
    <div class="runner-help">Avoid the ‚Äútrees‚Äù (circle + trunk). ‚ÄúR‚Äù auto-runs. Tap to jump!</div>
  </div>
</div>

<script>
(() => {
  // Canvas & DPI
  const canvas = document.getElementById('rehafRunner');
  const scoreEl = document.getElementById('runnerScore');
  const ctx = canvas.getContext('2d');
  function fitDPR() {
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    view.w = cssW; view.h = cssH;
  }
  const view = { w: canvas.clientWidth, h: canvas.clientHeight };
  window.addEventListener('resize', fitDPR, { passive:true });
  fitDPR();

  // Colors
  const C = {
    bg1: '#ffffff',
    ground: '#e7f4f1',
    line: 'rgba(0,171,154,.8)',  // teal
    dot: '#00453e',             // accent
    rFill1: '#00ab9a',
    rFill2: '#00786c',
    shadow: 'rgba(0,0,0,.10)'
  };

  // Game state
  let running = true;
  let score = 0;
  let best = 0;
  let tLast = 0;

  // Ground baseline
  const groundY = () => Math.round(view.h - 36);

  // Player ‚ÄúR‚Äù
  const R = {
    x: 80,
    y: 0,          // will be set to ground
    w: 32,
    h: 38,
    vy: 0,
    gravity: 0.8,
    jumpV: -12.5,
    onGround: true
  };

  // Obstacles (trees: lollipop shape)
  const obstacles = [];
  const spawn = {
    timer: 0,
    next: 900  // ms
  };

  function resetGame() {
    score = 0;
    R.y = groundY() - R.h;
    R.vy = 0;
    R.onGround = true;
    obstacles.length = 0;
    spawn.timer = 0;
    spawn.next = 900;
    running = true;
  }
  resetGame();

  function jump() {
    if (!running) {
      resetGame();
      return;
    }
    if (R.onGround) {
      R.vy = R.jumpV;
      R.onGround = false;
    }
  }

  // Controls
  window.addEventListener('keydown', (e) => {
    if ([' ', 'ArrowUp', 'KeyW', 'w'].includes(e.code) || [' ', 'ArrowUp', 'w', 'W'].includes(e.key)) {
      e.preventDefault();
      jump();
    }
  });
  canvas.addEventListener('pointerdown', jump, { passive: true });

  // Helpers
  function rand(min, max){ return Math.random()*(max-min)+min; }

  function spawnObstacle() {
    const base = groundY();
    // circle radius and trunk height
    const rad = rand(8, 16);
    const trunk = rand(22, 36);
    const gap = rand(260, 360); // distance between obstacles
    const speed = rand(3.8, 4.6);

    // Put new obstacle offscreen to the right, after last one
    const rightmost = obstacles.length ? obstacles[obstacles.length-1].x : view.w + 50;
    obstacles.push({
      x: Math.max(view.w + 20, rightmost + gap),
      baseY: base,
      r: rad,
      trunkH: trunk,
      speed
    });
  }

  function update(dt) {
    // Player physics
    R.vy += R.gravity;
    R.y += R.vy;
    const gy = groundY() - R.h;
    if (R.y >= gy) {
      R.y = gy;
      R.vy = 0;
      R.onGround = true;
    }

    // Obstacles
    spawn.timer += dt;
    if (spawn.timer >= spawn.next) {
      spawn.timer = 0;
      spawn.next = rand(700, 1200);
      spawnObstacle();
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      o.x -= o.speed;

      // Remove if offscreen
      if (o.x + o.r < -30) obstacles.splice(i, 1);

      // Collision (AABB vs circle+line envelope)
      const rLeft = R.x, rRight = R.x + R.w;
      const rTop = R.y, rBot = R.y + R.h;

      // Check circle hit
      const cx = o.x;
      const cy = o.baseY - o.trunkH - o.r; // top of trunk + radius
      const nearestX = Math.max(rLeft, Math.min(cx, rRight));
      const nearestY = Math.max(rTop, Math.min(cy, rBot));
      const distX = cx - nearestX;
      const distY = cy - nearestY;
      const hitCircle = (distX*distX + distY*distY) <= (o.r*o.r);

      // Check trunk hit (vertical line approximated as thin rect)
      const trunkLeft = o.x - 2, trunkRight = o.x + 2;
      const trunkTop = o.baseY - o.trunkH;
      const trunkBottom = o.baseY;
      const hitTrunk = !(rRight < trunkLeft || rLeft > trunkRight || rBot < trunkTop || rTop > trunkBottom);

      if (hitCircle || hitTrunk) {
        running = false;
        best = Math.max(best, Math.floor(score));
      }
    }

    // Score
    if (running) score += dt * 0.01;
    scoreEl.textContent = `${Math.floor(score)}${best ? ' / Best ' + best : ''}`;
  }

  function drawGround() {
    // Ground line
    ctx.strokeStyle = C.ground;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY()+0.5);
    ctx.lineTo(view.w, groundY()+0.5);
    ctx.stroke();
  }

  function drawR() {
    // body
    ctx.save();
    ctx.translate(R.x, R.y);
    // shadow
    ctx.fillStyle = C.shadow;
    ctx.beginPath();
    ctx.ellipse(R.w/2, R.h + 6, R.w*0.36, 6, 0, 0, Math.PI*2);
    ctx.fill();

    // main rounded rect
    const r = 8;
    ctx.beginPath();
    const x=0,y=0,w=R.w,h=R.h;
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    const grad = ctx.createLinearGradient(0,0,0,h);
    grad.addColorStop(0, C.rFill1);
    grad.addColorStop(1, C.rFill2);
    ctx.fillStyle = grad;
    ctx.fill();

    // white letter R
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 22px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('R', w/2, h/2 - 1);
    ctx.restore();
  }

  function drawTree(o) {
    // trunk (line)
    ctx.strokeStyle = C.line;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(o.x, o.baseY);
    ctx.lineTo(o.x, o.baseY - o.trunkH);
    ctx.stroke();

    // crown (circle)
    ctx.fillStyle = C.dot;
    ctx.beginPath();
    ctx.arc(o.x, o.baseY - o.trunkH - o.r, o.r, 0, Math.PI*2);
    ctx.fill();
  }

  function drawBackground() {
    ctx.fillStyle = C.bg1;
    ctx.fillRect(0,0, view.w, view.h);
  }

  function drawObstacles() {
    for (const o of obstacles) drawTree(o);
  }

  function drawGameOver() {
    if (running) return;
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillRect(0, 0, view.w, view.h);
    ctx.fillStyle = C.accent || '#00453e';
    ctx.font = 'bold 22px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over ‚Äî tap or press Space to restart', view.w/2, view.h/2);
    ctx.restore();
  }

  // Loop
  function loop(ts) {
    const dt = Math.min(32, ts - (tLast || ts));
    tLast = ts;

    update(dt);
    drawBackground();
    drawGround();
    drawObstacles();
    drawR();
    drawGameOver();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
<!-- ===== /RUNNER GAME ===== -->

</body>
</html>

